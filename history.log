ruby -e "puts 123"

print 123
"Hello".reverse
irb --simple-prompt
ri upcase
ri String#upcase
ri Object#inspect
"123".class
200.next
332.323.class
f=44.0
2323.5.round
2323.5.to_i
2323.5.ceil
"Hello"
'hello'
'hello' + ' ' + "dsds"

'1'*5
'I\ 'm escaped.'
puts '\ta\tb\nc\nd'
"\ta\tb\nc\nd"
puts "the number is #{val}"
.reverse
.capitalize
.upcase
.downcase
.length
.reverse.upcase.length
data_set=[1,2,3]
data_set2=[]
data_set[2]
data_set << "e" = (append)
data_set[0]=nil
.clear
= []
= nil - assigns a new pointer
[].inspect
[].to_s
[].join(",")
[].split(",")
[].sort
[].uniq
[].uniq!
[].delete_at(0)
[].delete(4)
[].push(3)
[].pop(3)
[].shift
[].unshift(1)
[1]+[2]
[1]-[2]
person={"pupa"=>"dupa", "dupa"=>"pupa"}
person["pupa"]
person.index("pupa")
{}.keys
{}.values
{}.length
{}.size
{}.to_a
{}.clear
:test_this
:test_this.object_id
[1,2].empty?
[1,2].include?(3)
2.between?(1,4)
{}.has_key(:dupa)
{}.has_value(:dupa)
x=1..10
(1..10).class
.begin
.end
.first
.last
x.include?(10)
x=1..10
alpha='a'..m
alpha.include?('b')
[*alpha]
z=[*x]
Hello=1 - const

if x<10

elsif x>20

else

end

puts "this is me" if name=="me"

require 'irb/completion'

unless boolean

end

case value

when boolean

when boolean

else

end

boolean ? code1:code2

puts x==1 ? "one":"two"

x=y||z

x||=y

loop do

end

break;next;redo;retry

while boolean
end

until boolean
end

x=0
loop do
	break if x>=20
	x+=2
	puts x
end

puts x+=2 while x<100 

5.times do
	puts "Hello"	
end

1.upto(5){puts "Hello"}	
5.downto(1){puts "Hello"}	
(1..5).each{puts "Hello"}	

1.upto(5) do |i|
	puts "Hello" + i.to_s
end

fr = ["1","2"]
fr.each do |num|	
	puts fruit.capitalize
end

for fruit in fr
	puts fruit.capitalize
end

1.times
.upto
.downto
.step

(1..5).each		
.step

"Hello".each
.each_line
.each_byte

[].each
.each_index
.each_with_index

{}.each
.each_key
.each_value
.each_pair

5.times {puts "Hello"}
1.upto(5) {|i| puts "Hello" + i.to_s}

array=[1,2,3]

array.each{|num| puts num+2}

(1..10).find{|i| i==5}
(1..10).find{|i| i%3==0}
(1..10).detect{|i| (1..10).include?(i*3)}

(1..10).find_all{|i| i%30==0}
(1..10).select{|i| (1..10).include?(i*3)}
(1..10).any? {|i| i%3==0}
(1..10).all {|i| i%3==0}
[*1..10].delete_if{|i| i%3==0}

m1={"pupa"=>"chef", "dupa"=>123}
m2={"pupa"=>"123", "dupa"=>321}
m1.merge(m2)
m1.merge(m2){|key, old,new| old}
m1.merge(m2){|k, o,n| o<n ? o:n}
m1.merge!(m2){|k, o,n| o<n ? o:n}

array.map do |num|
?> if num%2==0
>>  num+100
>> else
?>  num

map={"pupa"=>"dupa", "dupa"=>"pupa"}
>> end
end
map.map{|k,v| k}

map.map{|k,v| "#{k}:#{v}"}

1 <=> 2
2 <=> 2

arr=[3,4,6,7,3,1,2]
arr.sort{|v1,v2| v1<=> v2}
arr.sort{|v1,v2| v2<=> v1}
.sort
.reverse
arr.sort_by{|i| i}
map.to_a
map.sort {|item1, item2| item1[1] <=> item2[1]}
(1..10).inject{|memo, n| memo+n}
(1..10).inject(100){|memo, n| memo+n}
(1..10).inject(100){|memo, n| puts memo+n; memo}
fruits=["apple", "pear", "banana", "plum"]

longest_word=fruits.inject do |memo, fruit|
if memo.length>fruit.length
     memo
else
     fruit
end
 end

def some_name

end 

def welcome
    puts "Hello world"
 end

 def over_3?(age)
 	if age>3
 		true
 	else
 	    false
 	end
end  

class SomeName
	def set_noise
		@noise="Moo"
	end

	def makeNoise
		@noise
	end	

end

name=SomeName.new	    	

name.makeNose

module Romantic
	class Date
	end
end

dinner=Romantic::Date.new
dinner.date=Date.new

input=gets	
input.chomp
.chop

File.join("lib", "file.rb")
File.expand_path(__FILE__)
File.dirname(__FILE__)

file=File.new('irb_testfile.txt', 'w')
file.close

File.open('file.txt','r') do |file|
	//closes automatically
end

file=File.new("test.txt", "w")

file.puts "abc"

file.print "111"

file.write "abc"
file << "mnop"


file=File.new('irb_testfile.txt', 'r')
file.gets

File.open('File.txt', 'r') do |file|
	while line= file.gets
		puts "** " + line.chomp.reverse + " **"
	end
end

File.open('file1.txt', 'r') do |file|
	file.each_line {|line| puts line.upcase}	
end

File.delete
File.rename
require 'fileutils'
Fileutils.copy

File.exists?
.file?
.directory?
readable
writable?
executable?
.size
full_path=.expand_path
.basename
.extname
mtime
atime

Dir.pwd

.chdir
.entries

Dir.entries('.').each do |endtyr|

@first_name - instance variable
@@name - class variable(static)
surname - local variable
$LAST_NAME - global variable

ruby -cw c2f.rb - syntax check

irb --simple-prompt -rrbconfig

RbConfig::CONFIG["bindir"]

 ruby -e "puts $:"

 require "./loadee.rb" -> $: << "."; require "loadee.rb"

 rake --tasks

 rake clean_tmp

  rake admin:clean:tmp

  gem "hoe", "3.8.0"

  p Object.new.methods.sort

ri Object#respond_to\?
  .object_id

obj = Object.new
if obj.respond_to?("talk")
  obj.talk
else
  puts "Sorry, the object doesn't understand the 'talk' message."
end

def obj.multi_args(*x)
  puts "I can take zero or more arguments!"
end

def two_or_more(a,b,*c)
  puts "I require two or more arguments!"
  puts "And sure enough, I got: "
  p a, b, c
end

def default_args(a,b,c=1)
  puts "Values of variables: ",a,b,c
end

d="Hello"
a=d.dup
b=d.freeze
c=d.clone

Time.new.strftime("%m-%d-%y")

puts "at #{client.time["iso"]} my BTC balance: #{client.account("d61d3fe9-09ea-5633-a5a7-af6445c2f82c")["native_balance"]["amount"]}, sell price: #{client.sell_price({currency_pair: 'BTC-EUR'})["amount"]}, buy price: #{client.buy_price({currency_pair: 'BTC-EUR'})["amount"]}"


c = Class.new do
  def say_hello
    puts "Hello!"
  end
end

def Ticket.most_expensive(*tickets)
  tickets.max_by(&:price)
end

class Temperature
  def Temperature.c2f(celsius)
    celsius * 9.0 / 5 + 32
  end

  def Temperature.f2c(fahrenheit)
    (fahrenheit - 32) * 5 / 9.0
  end
end

Temperature::c2f(30)

Temperature.c2f(30)

class SomeInstance
	VENUES=["some", "more", "of that"]
end

puts SomeInstance::VENUES

puts RUBY_VERSION
puts RUBY_RELEASE_DATE

SomeInstance::VENUES << "dupa"

module StackLike
	def stack
		@stack||=[]
	end

	def add_to_stack(obj)
		stack.push(obj)
	end

	def take_from_stack(obj)
		stack.pop
	end
end

fake= -> {puts "111"}

fake.call

module MeFirst
  def report
    puts "Hello from module!"
  end
end

class Person
  prepend MeFirst
  def report
    puts "Hello from class!"
  end
end


p = Person.new
p.report

class Hey 
	def method_missing(m, *args)
		puts "instance method #{m} is missing"
	end

	def self.method_missing(m, *args)
		puts "class method #{m} is missing"
	end

	def Hey.method_missing(m, *args)
		puts "static method #{m} is missing"
		super
	end
end

module Tools
  class Hammer
  end
end

h = Tools::Hammer.new

obj = Object.new
def obj.show_me
  puts "Inside singleton method show_me of #{self}"
end

require "English"

puts $PID
puts $LOAD_PATH

::String.new()

def talk
  puts "Hello"
end

class Object
  private

  def talk
    puts "Hello"
  end
end

ruby -e 'p Kernel.private_instance_methods.sort'

if true 
	puts 111
end

if true then
	puts 111
end

if true; puts 222; end

if not x==1

if (!x)==1

unless x==1

puts "Big number!" if x > 100
puts "Big number!" unless x <= 100

case answer
when "y", "yes"
	puts "Good Bye!"
	exit 		
when "no"
	puts "Let's continue"	
end	

n = 1
begin
  puts n
  n = n + 1
end while n < 11
puts "Done!"

n = 1
while n < 11
  puts n
  n = n + 1
end
puts "Done!"

n = 1
loop





	 do
  n = n + 1
  next unless n == 10
  break
end

n = 1
loop do
  n = n + 1
  break if n > 9
end

n = 1
until n > 10
  puts n
  n = n + 1
end

n = 1
n = n + 1 until n == 10
puts "We've reached 10!"

c=[1,2,3]

for a in c 
	puts "#{a}"
end

def my_loop
  while true
    yield
  end
end

def my_loop
  yield while true
end

loop { puts "Looping forever!" }	

my_loop { puts "My-looping forever!" }

class Integer
  def my_times
    c = 0
    until c == self
      yield(c)
      c += 1
    end
    self
  end
end

5.my_times {|i| puts "I'm on iteration #{i}!" }

class Array
  def my_each
    size.my_times do |i|
      yield self[i]
    end
    self
  end
end

class Array
  # Put the definition of my_each here
  def my_map
    acc = []
    my_each {|e| acc << yield(e) }
    acc
  end
end

def block_args_unleashed
  yield(1,2,3,4,5)
end

block_args_unleashed do |a,b=1,*c,d,e|
  puts "Arguments:"
  p a,b,c,d,e
end

def block_local_variable
  x = "Original x!"
  3.times do |i;x|
    x = i
    puts "x in the block is now #{x}"
  end
  puts "x after the block ended is #{x}"
end

print "Enter a number: "
n = gets.to_i
begin
  result = 100 / n
rescue
  puts "Your number didn't work. Was it zero???"
  exit
end

def fussy_method(x)
  raise ArgumentError, "I need a number under 10" unless x < 10
end
fussy_method(20)

begin
  fussy_method(20)
rescue ArgumentError
  puts "That was not an acceptable number!"
end

raise "Problem!"

raise RuntimeError, "Problem!"
raise "Problem!"
raise RuntimeError, "Problem!"

begin 
  raise ArgumentError=>e
p e.class
end

begin
  fh = File.open(filename)

rescue => e
  logfile.puts("User tried to open #{filename}, #{Time.now}")
  logfile.puts("Exception: #{e.message}")
  raise
end


def line_from_file(filename, substring)
  fh = File.open(filename)
  begin
    line = fh.gets
    raise ArgumentError unless line.include?(substring)
  rescue ArgumentError
    puts "Invalid line!"
    raise
  ensure
    fh.close
  end
  return line
end

class MyNewException < Exception
end
raise MyNewException, "some new kind of error has occurred!"


class MyNewException < Exception
end
begin
  puts "About to raise exception..."
  raise MyNewException
rescue MyNewException => e
  puts "Just raised an exception: #{e}"
end

class InvalidLineError < StandardError
end
def line_from_file(filename, substring)
  fh = File.open(filename)
  line = fh.gets
  raise InvalidLineError unless line.include?(substring)
  return line

  rescue InvalidLineError
    puts "Invalid line!"
    raise
  ensure
    fh.close
end

dd=->(x,y) { x * y }
dd.call(3,3)

class Person
  attr_accessor :name
  def to_str
    name
  end
end

class Person
  attr_accessor :name, :age, :email
  def to_ary
    [name, age, email]
  end
end

String.instance_methods(false)

"I am a String object".methods
"I am a String object".methods.sort
str.singleton_methods
String.instance_methods

obj.private_methods
obj.public_methods
obj.protected_methods
obj.singleton_methods

MyClass.private_instance_methods
MyClass.protected_instance_methods
MyClass.public_instance_methods

class LetsCompare
include Comparable
def <=>
end
end

puts %q{You needn't escape apostrophes when using %q.}

text = <<EOM
This is the first line of text.
This is the second line.
Now we're done.
EOM

array = [1,2,3, <<EOM, 4]
This is the here-doc!
It becomes array[3].
EOM
p array

string = "Ruby is a cool language."
string[5,10]

string = "Ruby is a cool language."

string[/c[ol ]+/] 

string["cool"] = "great"

"My name is #{class Person
                   attr_accessor :name
                 end
                 d = Person.new
                 d.name = "David"
                 d.name
                 }."
class Person
>>   attr_accessor :name
>>   def to_s
>>     name
>>   end
>> end

string.include?("Ruby")
string.start_with?("Ruby")
 string.end_with?("!!!")

 string.empty?                 
 string.count("a")
  string.count("A-Z")
  string.count("^aey. ")
  string.index("cool")
  string.rindex("cool")
  "a".ord

  97.chr
  "a".equal?("a")
  string.upcase
  string.downcase
  string.swapcase
  string.capitalize
  string.rjust(25)
  string.ljust(25)
  string.rjust(25,'.')
  string.rjust(25,'><')
  "The middle".center(20, "*")
  "The middle".center(21, "*")
  string.strip
  string.lstrip
  string.rstrip
  .chop
  .chomp
string[7..14]
"David A. Black".chomp('ck')
string.clear
string.replace("David A. Black")
"David A. Black".delete("abc")
"David A. Black".delete("a-e","^c")
"a".succ
"100".to_i(17)
"100".oct
"100".hex
puts __ENCODING__
 str.encoding
 str.encode("US-ASCII")
 s =:x
  Symbol.all_symbols
Symbol.all_symbols.include?(:abc)
Symbol.all_symbols.grep(123)

require 'date'
Date.parse("April 24 1705").england.strftime("%B %d %Y")

require 'date'
require 'time'
Date.today
puts Date.today
puts Date.new(1959,2,1)
Date.parse
Time.new
Time.at(10000)
Time.mktime(2007,10)
Time.parse('March 2007')
puts DateTime.new(2009, 1, 2, 3, 4, 5)
puts DateTime.now
puts DateTime.parse("October 23, 1973, 10:34 AM")
dt = DateTime.now
dt.year
t = Time.now
t.month
d.monday?
t = Time.now
t.strftime("%m-%d-%y")
t.strftime("Today is %x")
Date.today.rfc2822
DateTime.now.httpdate
d = Date.today
puts d.next
puts d.next_year
puts d.next_month(3)
puts d.prev_day(10)

hash = { "red" => "ruby", "white" => "diamond", "green" => "emerald" }
hash.each.with_index {|(key,value),i|
  puts "Pair #{i} is: #{key}/#{value}"
}

%w{...}
%i{...}

a = Array.new
Array.new(3) {n+1; n*10}

%i{ a b c }
Array.try_convert(obj)

a = [1,2,3,4]
a.unshift(0)

a = [1,2,3,4]
a.push(5)

a = [1,2,3,4]
a << 5

a = [1,2,3,4,5]
a.push(6,7,8)
.pop
.shift

a = %w{ one two three four five }

a.pop(2)
a.shift(2)

[1,2,3].concat([4,5,6])

[1]+[2]

.flatten
.flatten(1)
.flatten!()
.reverse

["abc", "def", 123].join
.join(", ")

a = %w{ one two three }
=> ["one", "two", "three"]
>> a * "-"
=> "one-two-three"

[1,2,3,1,4,3,5,1].uniq

.compact
.size
.empty?
.include?
.count
.first
.last
.sample

state_hash={"Connecticut"=>1}
conn_abbrev = state_hash.fetch("Connecticut")

state_hash.fetch("Nebraska", "Unknown state")

two_states = state_hash.values_at("New Jersey","Delaware")

h = Hash.new(0)
h = Hash.new {|hash,key| hash[key] = 0 }
.update
.merge

h = Hash[1,2,3,4,5,6] {1=>2, 3=>4, 5=>6}

h.select {|k,v| k > 1 }
h.invert
h.reject {|k,v| k > 1 }
.clear

h.has_key?(1)
h.include?(1)
h.key?(1)
h.member?(1)
h.has_value?("three") 
h.value?("three")
h.value?("three")
h.size

add_to_city_database("New York City",
  state: "New York",
  population: 7000000,
  nickname: "Big Apple")

  my_method({ "NY" => "New York" }, 100, "another argument")

  def m(a:, b:)
>>   p a,b
>> end

def m(a: 1, b: 2, **c)

r = Range.new(1,100)
r = 1..100
r = 1...100 (exclusive)
.begin
.end
.exclude_end?
.cover("Abd")
r.include?("a")


=> 1.0..2.0
>> r.include?(1.5)
=> true

require 'set'

>> new_england = ["Connecticut", "Maine", "Massachusetts",
                  "New Hampshire", "Rhode Island", "Vermont"]
=> ["Connecticut", "Maine", "Massachusetts",
    "New Hampshire","Rhode Island", "Vermont"]
>> state_set = Set.new(new_england)

tri_state << "Pennsylvania"
tri_state.delete("Connecticut")
tri_state.add?("Pennsylvania")

 tri_state = Set.new(["Connecticut", "New Jersey", "New York"])
=> #<Set: {"Connecticut", "New Jersey", "New York"}>
# Subtraction (difference/-)
>> state_set - tri_state
=> #<Set: {"Maine", "Massachusetts", "New Hampshire", "Rhode Island",
"Vermont"}>
# Addition (union/+/|)
>> state_set + tri_state
=> #<Set: {"Connecticut", "Maine", "Massachusetts", "New Hampshire",
"Rhode Island", "Vermont", "New Jersey", "New York"}>
# Intersection (&)
>> state_set & tri_state
=> #<Set: {"Connecticut"}>
>> state_set | tri_state
=> #<Set: {"Connecticut", "Maine", "Massachusetts", "New Hampshire",
"Rhode Island", "Vermont", "New Jersey", "New York"}>

state_set ^ tri_state

 small_states = Set.new(["Connecticut", "Delaware", "Rhode Island"])
=> #<Set: {"Connecticut", "Delaware", "Rhode Island"}>
>> tiny_states = Set.new(["Delaware", "Rhode Island"])
=> #<Set: {"Delaware", "Rhode Island"}>
>> tiny_states.subset?(small_states)
=> true
>> small_states.superset?(tiny_states)
=> true

[10,20,30].reduce{ |sum, n| sum + n }


[1,2,3,4,5,6,7,8,9,10].find {|n| n > 5 }
r.select {|color| color.size == 6 }
r.drop_while {|color| color.size < 5 }
r.map {|color| color[0,3] }
a.reject {|item| item > 5 }
.find_all
colors.grep(/o/)
.grep(String)
.grep(50..10000)

colors = %w{ red orange yellow green blue indigo violet }
=> ["red", "orange", "yellow", "green", "blue", "indigo", "violet"]
>> colors.grep(/o/) {|color| color.capitalize }
=> ["Orange", "Yellow", "Indigo", "Violet"]

enumerable.grep(expression) {|item| ... }

enumerable.select {|item| expression === item}.map {|item| ... }

colors.group_by {|color| color.size }

class Person
  attr_accessor :age
  def initialize(options)
    self.age = options[:age]
  end
  def teenager?
    (13..19) === age
  end
end

people = 10.step(25,3).map {|i| Person.new(:age => i) }

teens =  people.partition {|person| person.teenager? }
.first
.take(2)
.drop(2)
states.take_while {|s| /N/.match(s) }
states.drop_while {|s| /N/.match(s) }
[1,3,5,4,2].max
.min
%w{ Ruby C APL Perl Smalltalk }.min {|a,b| a.size <=> b.size }
%w{ Ruby C APL Perl Smalltalk }.minmax
%w{ Ruby C APL Perl Smalltalk }.minmax_by {|lang| lang.size }
.min_by
.max_by
[1,2,3].reverse_each {|e| puts e * 10 }
%w{a b c }.each_index {|i| puts i }
 letters.each_with_index {|(key,value),i| puts i }

 array.each.with_index do |color, i|
?>   puts "Color number #{i} is #{color}."
>> end

array = [1,2,3,4,5,6,7,8,9,10]
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>> array.each_slice(3) {|slice| p slice }
array.each_cons(3) {|cons| p cons }
.cycle(n)

[1,2,3,4].inject(0) {|acc,n| acc + n }

[1,2,3,4].inject do |acc,n|
     puts "adding #{acc} and #{n}...#{acc+n}"
     acc + n
   end
adding 1 and 2...3
adding 3 and 3...6
adding 6 and 4...10

names.map {|name| name.upcase }

names.map(&:upcase)

names = %w{ David Yukihiro Chad Amy }
names.map!(&:upcase)

str = "abcde"
str.each_byte {|b| p b }

str = "abcde"
str.each_char {|c| p c }

def <=>(other_painting)
  self.price <=> other_painting.price
end

year_sort = [pa1, pa2, pa3, pa4, pa5].sort do |a,b|
  a.year <=> b.year
end

["2",1,5,"3",4,"6"].sort {|a,b| a.to_i <=> b.to_i }
.sort_by(&:to_i)

e = Enumerator.new do |y|
  y << 1
  y << 2
  y << 3
end

e = Enumerator.new do |y|
  (1..3).each {|i| y << i }
end

e = Enumerator.new do |y|
  puts "Starting up the block!"
  (1..3).each {|i| y << i }
  puts "Exiting the block!"
end
p e.to_a
p e.select {|x| x > 2 }

a = [1,2,3,4,5]
e = Enumerator.new do |y|
  total = 0
  until a.empty?
    total += a.pop
    y << total
  end
end

names = %w{ David Black Yukihiro Matsumoto }
e = names.enum_for(:select)

e.each{}

e = names.enum_for(:inject, "Names: ")

e.each {|string, name| string << "#{name}..." }

str = "Hello"

str.each_byte {|b| puts b }

str.enum_for(:each_byte)

clase SomeClass
include Enumerable
def each
end
end

give_me_an_array(array.to_enum)

names = %w{ David Yukihiro }
e = names.to_enum
puts e.next
puts e.next
e.rewind
puts e.next

module Music
  class Scale
    NOTES = %w{ c c# d d# e f f# g a a# b }

    def play
      NOTES.each {|note| yield note }
    end
  end
end

scale = Music::Scale.new
scale.play {|note| puts "Next note is #{note}" }

 names = %w{ David Black Yukihiro Matsumoto }
=> ["David", "Black", "Yukihiro", "Matsumoto"]
>> names.each_slice(2).map do |first, last|
     "First name: #{first}, last name: #{last}\n"
   end
=> ["First name: David, last name: Black\n",
    "First name: Yukihiro, last name: Matsumoto\n"]

    (1..Float::INFINITY).select {|n| n % 3 == 0 }.first(10)

    (1..Float::INFINITY).lazy

    (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }

    (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }.first(10)

    y_enum = (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
=> #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>
>> my_enum.take(5).force
=> [3, 6, 9, 12, 15]
>> my_enum.take(10).force
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]


def fb_calc(i)
  case 0
  when i % 15
    "FizzBuzz"
  when i % 3
    "Fizz"
  when i % 5
    "Buzz"
  else
    i.to_s
  end
end

def fb(n)
  (1..Float::INFINITY).lazy.map {|i| fb_calc(i) }.first(n)
end

//.class
=> Regexp

puts "Match!" if /abc/.match("The alphabet starts with abc.")
puts "Match!" if "The alphabet starts with abc.".match(/abc/)

puts "Match!" if /abc/ =~ "The alphabet starts with abc."
puts "Match!" if "The alphabet starts with abc." =~ /abc/

"The alphabet starts with abc" =~ /abc/
=> 25
>> /abc/.match("The alphabet starts with abc.")
=> #<MatchData "abc">

/((a)((b)c))/.match("abc")

re = /(?<first>\w+)\s+((?<middle>\w\.)\s+)?(?<last>\w+)/

m = re.match("David A. Black")

#<MatchData "David A. Black" first:"David" middle:"A." last:"Black">

puts $~

/abc/.inspect
array.find_all {|e| e.size > 10 and /\d/.match(e) }

 "testing 1 2 3 testing 4 5 6".scan(/\d/)

 "one two three".scan(/\w+/) {|n| puts "Next number: #{n}" }

 "Ruby".split(//)

 "typigraphical error".sub(/i/,"o")

 "capitalize the first vowel".sub(/[aeiou]/) {|s| s.upcase }

 "capitalize every word".gsub(/\b\w/) {|s| s.upcase }

"aDvid".sub(/([a-z])([A-Z])/, '\2\1')

/(abc)/.match("abc")

puts "Match!" if re.match(string)
puts "Match!" if string =~ re
puts "Match!" if re === string

print "Continue? (y/n) "
answer = gets
case answer
when /^y/i
  puts "Great!"
when /^n/i
  puts "Bye!"
  exit
else
  puts "Huh?"
end

["USA", "UK", "France", "Germany"].grep(/[a-z]/)
 ["USA", "UK", "France", "Germany"].grep(/[a-z]/) {|c| c.upcase }

 STERR.puts("problem")
 STERR.write("problem")

 STDIN.each {|line| p line }

 $/ = "NEXT"

 STDIN.select {|line| line =~ /\A[A-Z]/ }

 STDIN.map {|line| line.reverse }

 File.open("records.txt") do |f|
  while record = f.gets
    name, nationality, instrument, dates = record.chomp.split('|')
    puts "#{name} (#{dates}), who was #{nationality},
 played #{instrument}. "
  end
end

File.open("records.txt") do |f|
  f.each do |record|
    name, nationality, instrument, dates = record.chomp.split('|')
    puts "#{name} (#{dates}), who was #{nationality},
  played #{instrument}. "
  end
end

# Sample record in members.txt:
# David Black male 55
count = 0
total_ages = File.readlines("members.txt").inject(0) do |total,line|
  count += 1
  fields = line.split
  age = fields[3].to_i
  total + age
end
puts "Average age of group: #{total_ages / count}."

count = 0
total_ages = File.open("members.txt") do |f|
  f.inject(0) do |total,line|

    count += 1
    fields = line.split
    age = fields[3].to_i
    total + age
  end
end
puts "Average age of group: #{total_ages / count}."

>> File.open("no_file_with_this_name")
Errno::ENOENT: No such file or directory - no_file_with_this_name
>> f = File.open("/tmp")
=> #<File:/tmp>
>> f.gets
Errno::EISDIR: Is a directory - /tmp
>> File.open("/var/root")
Errno::EACCES: Permission denied - /var/root

FileTest.exist?("/usr/local/src/ruby/README")

FileTest.directory?("/home/users/dblack/info")
FileTest.file?("/home/users/dblack/info")
FileTest.symlink?("/home/users/dblack/info")

FileTest.readable?("/tmp")
FileTest.writable?("/tmp")
FileTest.executable?("/home/users/dblack/setup")


FileTest.size("/home/users/dblack/setup")
FileTest.zero?("/tmp/tempfile")

test ?e, "/tmp"

Dir.entries("/usr/local/src/ruby/lib/minitest")

[".", "..", ".document", "autorun.rb", "benchmark.rb", "hell.rb",
"mock.rb", "parallel_each.rb", "pride.rb", "README.txt", "spec.rb",
"unit.rb"]

d = Dir.new("/usr/local/src/ruby/lib/minitest")
entries = d.entries
entries.delete_if {|entry| entry =~ /^\./ }
entries.map! {|entry| File.join(d.path, entry) }
entries.delete_if {|entry| !File.file?(entry) }
print "Total bytes: "
puts entries.inject(0) {|total, entry| total + File.size(entry) }

 Dir["/usr/local/src/ruby/include/ruby/r*.h"]

 Dir.glob("info*")      # []
Dir.glob("info", File::FNM_CASEFOLD   # ["Info", "INFORMATION"]


Dir.glob("*info*")
=> []
>> Dir.glob("*info*", File::FNM_DOTMATCH)
=> [".information"]
>> Dir.glob("*info*", File::FNM_DOTMATCH | File::FNM_CASEFOLD)
=> [".information", ".INFO", "Info"]

Dir["*info*"]

Dir.glob("*info*", 0)

dir = "/usr/local/src/ruby/lib/minitest"
entries = Dir["#{dir}/*"].select {|entry| File.file?(entry) }
print "Total bytes: "
puts entries.inject(0) {|total, entry| total + File.size(entry) }


require 'fileutils'
.cp
.mkdir
FileUtils.mv("baker.rb.bak", "backup")

 File.exist?("backup/super.rb")
=> true
>> FileUtils.rm("./backup/super.rb")
=> ["./backup/super.rb"]
>> File.exist?("backup/super.rb")
=> false
=> 0


 FileUtils.rm_rf("backup")
=> ["backup"]
>> File.exist?("backup")
=> false

FileUtils::DryRun.rm_rf("backup")

FileUtils::DryRun.ln_s("backup", "backup_link")
 FileUtils::NoWrite.rm("backup/super.rb")
=> nil
>> File.exist?("backup/super.rb")
=> true

require 'pathname'
=> true
>> path = Pathname.new("/Users/dblack/hacking/test1.rb")
=> #<Pathname:/Users/dblack/hacking/test1.rb>

path.basename

path.dirname
>> Dir["backup/*"]
=> ["backup/baker.rb.bak", "backup/ensure.rb", "backup/super.rb"]

path.extname

 path.ascend do |dir|
?>   puts "Next level up: #{dir}"
>> end

module DeCommenter
  def self.decomment(infile, outfile, comment_re = /\A\s*#/)
    infile.each do |inline|
      outfile.print inline unless inline =~ comment_re
    end
  end
end

File.open("myprogram.rb") do |inf|
  File.open("myprogram.rb.out", "w") do |outf|
    DeCommenter.decomment(inf, outf)
  end
end

tf = Tempfile.new("my_temp_file").

require 'open-uri'
rubypage = open("http://rubycentral.org")
puts rubypage.gets

class << object
  # method and constant definitions here
end

str = "I am a string"
class << str
  def twice
    self + " " + self
  end
end
puts str.twice

str = "I am a string"
class << str
  def twice
    self + " " + self
  end
end
puts str.twice

N = 1
obj = Object.new
class << obj
  N = 2
end


class Ticket
  class << self
    def most_expensive(*tickets)
      tickets.max_by(&:price)
    end
  end
end

class << Ticket
  def most_expensive(tickets)
  # etc.


module Secretive
  def name
    "[not available]"
  end
end

class << ruby
  include Secretive
end

c = C.new
class << c
  include M
  p ancestors
end

string = "a string"
p string.singleton_class.ancestors

class C
end

 def C.a_class_method
[10] pry(main)*   puts "singleton method"
[10] pry(main)* end

C.a_class_method

12] pry(main)> class D<C
[12] pry(main)* end

D.a_class_method

gem install activesupport
require 'active_support/core_ext'

require 'active_support'

"person".pluralize

"little_dorritt".titleize

class String
  alias __old_reverse__ reverse
  def reverse
    $stderr.puts "Reversing a string!"
    __old_reverse__
  end
end
puts "David".reverse


class String
  alias __old_reverse__ reverse
end

class String
  alias_method :__old_reverse__, :reverse
end

w/active support

Time.now.to_s(:db)

Time.now.to_s(:number)

Time.now.to_s(:rfc822)

object.extend(MyModule)

class Car
  def self.makes
    %w{ Honda Ford Toyota Chevrolet Volvo }
  end
end

class Car
  class << self
    def makes
      %w{ Honda Ford Toyota Chevrolet Volvo }
    end
  end
end

module Makers
  def makes
    %w{ Honda Ford Toyota Chevrolet Volvo }
  end
end

class Car
  extend Makers
end

Car.extend(Makers)

p Car.singleton_class.ancestors

module Shout
refine String do
  def shout
    self.upcase +"!!!!"
  end
end
end

class Person
  attr_accessor :name

  using Shout
  def announce  
  puts "announcing #{name.shout}"
  end
 end
 
 davaid=person.new
 dadid.name="David"
 david.announce

 pr = Proc.new { puts "Inside a Proc's block" }
 pr.call

 p=proc { puts "Hi!" }

 def call_a_proc(&block)
  block.call
end
call_a_proc { puts "I'm the block...or Proc...or something." }   

p = Proc.new {|x| puts x.upcase }
%w{ David Black }.each(&p)

 p = Proc.new {|x| puts x.upcase }
%w{ David Black }.each(&p)

p = Proc.new { puts "This proc argument will serve as a code block." }
capture_block(&p)

def capture_block(&block)
  block.call
end
capture_block { puts "Inside the block" }

p = Proc.new { puts "This proc argument will serve as a code block." }
capture_block(&p)

%w{ david black }.map(&:capitalize)

%w{ david black }.map &:capitalize

pr = Proc.new {|x| puts "Called with argument #{x}" }
pr.call(100)

lam = lambda { puts "A lambda!" }


class C
  def talk
    puts "Method-grabbing test!  self is #{self}."
  end
end

c = C.new
meth = c.method(:talk)

class D < C
end

d = D.new
unbound = meth.unbind
unbound.bind(d).call

class A
  def a_method
    puts "Definition in class A"
  end
end

class B < A
  def a_method
    puts "Definition in class B (subclass of A)"
  end
end

class C < B
end

c = C.new

A.instance_method(:a_method).bind(c).call

class C
  def call_original
    A.instance_method(:a_method).bind(self).call
  end
end

mult = lambda {|x,y| x * y }
twelve = mult[3,4]

twelve = mult.(3,4)

m = gets.chomp
eval("def #{m}; puts 'Hi!'; end")
eval(m)

def use_a_binding(b)
  eval("puts str", b)
end
str = "I'm a string in top-level binding!"
use_a_binding(binding)


p self
a = []
a.instance_eval { p self }

class C
  def initialize
    @x = 1
  end
end

c = C.new
c.instance_eval { puts @x }

>> var = "initialized variable"
=> "initialized variable"
>> class C
>>   puts var
>> end

NameError: undefined local variable or method `var' for C:Class
        from (irb):3
>> C.class_eval { puts var }
initialized variable

C.class_eval { define_method("talk") { puts var }  }

Thread.new do
  puts "Starting the thread"
  sleep 1
  puts "At the end of the thread"
end
puts "Outside the thread"

t = Thread.new do
  puts "Starting the thread"
  sleep 1
  puts "At the end of the thread"
end
puts "Outside the thread"
t.join

puts "Trying to read in some files..."
t = Thread.new do
  (0..2).each do |n|
   begin
    File.open("part0#{n}") do |f|
      text << f.readlines
    end
    rescue Errno::ENOENT
      puts "Message from thread: Failed on n=#{n}"
      Thread.exit
    end
  end
end
t.join
puts "Finished!"


f = Fiber.new do
  puts "Hi."
  Fiber.yield
  puts "Nice day."
  Fiber.yield
  puts "Bye!"
end
f.resume
puts "Back to the fiber:"
f.resume
puts "One last message from the fiber:"
f.resume
puts "That's all!"

require 'socket'
s = TCPServer.new(3939)
while true
  conn = s.accept
  conn.puts "Hi. Here's the date."
  conn.puts `date`
  conn.close
end

t = Thread.new { Thread.stop; a = 3 }
t.run

t = Thread.new do
  Thread.current[:message] = "Hello"
end
t.join
p t.keys
puts t[:message]

system("date")

system("cat")

$?

d = `date`

command = "date"

%x(#{command})

class Cookbook
  attr_accessor :title, :author
  def initialize
    @recipes = []
  end

  def method_missing(m,*args,&block)
    @recipes.send(m,*args,&block)
  end
end

def respond_to_missing?(m, include_private = false)
  /set_/.match(m) || super
end


module M
  def self.included(c)
    puts "I have just been mixed into #{c}."
  end
end
class C
  include M
end

module M
  def self.included(cl)
    def cl.a_class_method
      puts "Now the class has a new class method."
    end
  end

  def self.extended(cl)

  end

  def an_inst_method
    puts "This module supplies this instance method."
  end
end


class C
  include M
end

c = C.new
c.an_inst_method
C.a_class_method

class C
  def self.inherited(subclass)
    puts "#{self} just got subclassed by #{subclass}."
  end
end
class D < C
end

class C
  def self.inherited(subclass)
    puts "#{self} just got subclassed by #{subclass}."
  end
end
class D < C
end


class C
  def self.const_missing(const)
    puts "#{const} is undefinedâ€”setting it to 1."
    const_set(const,1)
  end
end

class C
  def self.method_added(m)

  end
  def self.singleton_method_added(m)
    puts "Method #{m} was just defined."
  end
end

p local_variables
p global_variables.sort

class Person
  attr_accessor :name, :age
  def initialize(name)
    @name = name
  end
end

david = Person.new("David")
david.age = 55
p david.instance_variables

:_

require_relative 'callertools'
def x
  y
end

def y
  z
end
def z
  stack = CallerTools::Stack.new
  puts stack.report
end
x